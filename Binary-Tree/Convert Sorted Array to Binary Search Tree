//递归思想很好做~注意返回空

class Solution {
	TreeNode * dfs(int start,int end,vector<int> &num)
	{
			if(start <= end)
			{
				int mid = (start + end) / 2;
				TreeNode *newNode = new TreeNode(num[mid]);
				newNode->left = dfs(start,mid - 1,num);
				newNode->right = dfs(mid + 1,end,num);
				return newNode;
			}
			else
				return NULL;
	}

public:
    TreeNode *sortedArrayToBST(vector<int> &num) {
		if(num.size() < 1)
			return nullptr;
		return dfs(0,num.size()-1,num);
        
    }
};
